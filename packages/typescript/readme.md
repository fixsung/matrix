<!--
 * @Author: songyzh
 * @Date: 2022-06-16 10:39:36
 * @LastEditors: songyzh
 * @LastEditTime: 2022-06-17 13:51:05
 * @Description:
-->

# TypeScript 笔记

## TypeScript 的必要性

如果能保证对某种类型只做该类型允许的操作，这就叫做**类型安全**。而**类型检查**是为了保证类型安全的。类型检查可以在运行时做，也可以运行之前的编译期做。这是两种不同的类型，前者叫做**动态类型检查**，后者叫做**静态类型检查**。

动态类型检查 在源码中不保留类型信息，对某个变量赋什么值、做什么操作都是允许的，写代码很灵活，但代码中很容易藏着一些类型不匹配的隐患。

静态类型检查则是在源码中保留类型信息，声明变量要指定类型，对变量做的操作要和类型匹配，会有专门的编译器在编译期间做检查。静态类型给写代码增加了一些难度，因为你除了要考虑代码要表达的逻辑之外，还要考虑类型逻辑：变量是什么类型的、是不是匹配、要不要做类型转换等。

## 为什么叫类型体操

静态类型编程语言都有自己的类型系统，从简单到复杂可以分为 3 类：

- 简单类型系统

- 支持泛型的类型系统
  它给类型系统增加了一些灵活性，在整体比较固定，部分变量的类型有变化的情况下，可以减少很多重复代码。声明时把会变化的类型声明成泛型（也就是类型参数），在调用的时候再确定类型。
- 支持类型编程的类型系统
  对传入的类型参数（泛型）做各种逻辑运算，产生新的类型，这就是类型编程。

## 高级类型

高级类型的特点是传入类型参数，经过一系列类型运算逻辑后，返回新的类型。

- 条件：extends ? : TypeScript 类型系统里的 if else

- 推导：infer 提取类型的一部分

- 联合：｜

- 交叉：& 同一类型可以合并，不同的类型没法合并

- 映射类型 对索引类型进行修改

  - keyof T 是查询索引类型中所有的索引，叫做索引查询。

  - T[Key] 是取索引类型某个索引的值，叫做索引访问。

  - in 是用于遍历联合类型的运算符。

  - 除了值可以变化，索引也可以做变化，用 as 运算符，叫做重映射。

  - 这里的 & string 可能大家会迷惑，解释一下：因为索引类型（对象、class 等）可以用 string、number 和 symbol 作为 key，这里 keyof T 取出的索引就是 string | number | symbol 的联合类型，和 string 取交叉部分就只剩下 string 了。就像前面所说，交叉类型会把同一类型做合并，不同类型舍弃。

## 通过模式匹配提取

Typescript 类型的模式匹配是通过 extends 对类型参数做匹配，结果保存到通过 infer 声明的局部类型变量里，如果匹配就能从该局部变量里拿到提取出的类型。

> any 和 unknown 的区别： any 和 unknown 都代表任意类型，但是 unknown 只能接收任意类型的值，而 any 除了可以接收任意类型的值，也可以赋值给任意类型（除了 never）。类型体操中经常用 unknown 接受和匹配任何类型，而很少把任何类型赋值给某个类型变量。

## 重新构造

TypeScript 的 type、infer、类型参数声明的变量都不能修改，想对类型做各种变换产生新的类型就需要重新构造。

## 递归复用

递归是把问题分解为一系列相似的小问题，通过函数不断调用自身来解决这一个个小问题，直到满足结束条件，就完成了问题的求解。

TypeScript 类型系统不支持循环，但支持递归。当处理数量（个数、长度、层数）不固定的类型的时候，可以只处理一个类型，然后递归的调用自身处理下一个类型，直到结束条件也就是所有的类型都处理完了，就完成了不确定数量的类型编程，达到循环的效果。

## 通过数组长度计数

TypeScript 类型系统中没有加减乘除运算符，但是可以通过构造不同的数组然后取 length 的方式来完成数值计算，把数值的加减乘除转化为对数组的提取和构造。

## 分布式条件类型

当类型参数为联合类型，并且在条件类型左边直接引用该类型参数的时候，TypeScript 会把每一个元素单独传入来做类型运算，最后再合并成联合类型，这种语法叫做分布式条件类型

当 A 是联合类型时：

A extends A 这种写法是为了触发分布式条件类型，让每个类型单独传入处理的，没别的意义。

A extends A 和 [A] extends [A] 是不同的处理，前者是单个类型和整个类型做判断，后者两边都是整个联合类型，因为只有 extends 左边直接是类型参数才会触发分布式条件类型。

需要动态生成类型的场景，必然要用类型编程做一些运算。有的场景下可以不用类型编程，但是用了能够有更精准的类型提示和检查。
